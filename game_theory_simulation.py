# -*- coding: utf-8 -*-
"""Lab1: game_theory_starter

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1o08Q6tafkIFXCQqX_w6r0HqT2-dpzR13
"""

# Define constants: in Economics/Game Theory these can really matter!
YOU_COOPERATE: int = -1
YOU_CHEAT: int = 0
THEY_COOPERATE: int = 3
THEY_CHEAT: int = 0

# Define names of actions.
COOPERATE: str = "cooperate"
CHEAT: str = "cheat"

# Define the players.
from typing import List, Dict, Set

# This is the basic setup of a player
# You cannot actually implement this player
class Player(object):
  def __init__(self):
    self.score: int = 0
    self.history: List[str] = []
  def play(self, past_plays: List[str]) -> str:
    raise ValueError("need to define play!")

# This player always cooperates
class AlwaysNice(Player):
  def __init__(self):
    super().__init__()
  def play(self, past_plays: List[str]) -> str:
    return COOPERATE

# This player always cheats
class AlwaysMean(Player):
  def play(self, past_plays: List[str]) -> str:
    return CHEAT

# Used https://stackoverflow.com/questions/33359740/random-number-between-0-and-1-in-python for help with python random
import random

# This player starts cooperating, then copies the opponent's last move
class CopyCat(Player):
  def play(self, past_plays: List[str]) -> str:
    if len(self.history) == 0:
      return COOPERATE;
    else:
      return past_plays[-1]

# This player starts cooperating, but if it gets cheated once, it always cheats afterwards
class Grudger(Player):
  def play(self, past_plays: List[str]) -> str:
    if any([x==CHEAT for x in past_plays]):
      return CHEAT
    else:
      return COOPERATE

# This player tends to cooperate but sometimes does what the other player just did
class MyPlayer(Player):
  def play(self, past_plays: List[str]) -> str:
    if len(self.history) == 0:
      return COOPERATE
    elif random.uniform(0, 1) < .75:
      return COOPERATE
    else:
      return past_plays[-1]

# This player only cheats if its opponent's last two moves were cheat
class CopyKitten(Player):
  def play(self, past_plays: List[str]) -> str:
    if len(self.history) == 0 or len(self.history) == 1:
      return COOPERATE;
    elif past_plays[-1] == CHEAT and past_plays[-2] == CHEAT:
      return CHEAT
    else:
      return COOPERATE

# This player is random, and will cheat or cooperate with equal probability.
class Random(Player):
  def play(self, past_plays: List[str]) -> str:
    if random.uniform(0, 1) < .5:
      return COOPERATE
    else:
      return CHEAT

# Define the playing of a single round:
def play_game(p1, p2):
  """
  This method takes two players and plays them against each other for one round.
  This updates the history and score on the Player objects.

  :param p1: The first player, any kind.
  :param p2: The second player, any kind.
  """
  p1_act: str = p1.play(p2.history)
  p2_act: str = p2.play(p1.history)

  p1.history.append(p1_act)
  p2.history.append(p2_act);

  if p1_act == COOPERATE:
    p1.score += YOU_COOPERATE
    p2.score += THEY_COOPERATE
  else:
    p1.score += YOU_CHEAT
    p2.score += THEY_CHEAT

  if p2_act == COOPERATE:
    p2.score += YOU_COOPERATE
    p1.score += THEY_COOPERATE
  else:
    p2.score += YOU_CHEAT
    p2.score += THEY_CHEAT

  print(p1_act, p2_act, p1.score, p2.score)

# Following are some example games with Random. Games result as follows:

# AlwaysMean beats AlwaysNice, CopyCat, Grudger, MyPlayer, CopyKitten, and Random
# AlwaysNice, CopyCat, Grudger, MyPlayer, and CopyKitten tie when playing each other
# Random tends to beat AlwaysNice, MyPlayer, and CopyKitten
# Random either beats CopyCat or ties with it
# Grudger tends to beat Random

# Nice vs. Random
nice = AlwaysNice()
random1 = Random()

print("NICE vs RANDOM")
for _ in range(20):
  play_game(nice, random1)
print("NICE: {}, RANDOM: {}\n".format(nice.score, random1.score))

# Mean vs. Random
mean = AlwaysMean()
random1 = Random()

print("MEAN vs RANDOM")
for _ in range(20):
  play_game(mean, random1)
print("MEAN: {}, RANDOM: {}\n".format(mean.score, random1.score))

# CopyCat vs. Random
copyc = CopyCat()
random1 = Random()

print("COPYCAT vs RANDOM")
for _ in range(20):
  play_game(copyc, random1)
print("COPYCAT: {}, RANDOM: {}\n".format(copyc.score, random1.score))

# Grudger vs. Random
grudge = Grudger()
random1 = Random()

print("GRUDGER vs RANDOM")
for _ in range(20):
  play_game(grudge, random1)
print("GRUDGER: {}, RANDOM: {}\n".format(grudge.score, random1.score))

# MyPlayer vs. Random
me = MyPlayer()
random1 = Random()

print("MYPLAYER vs RANDOM")
for _ in range(20):
  play_game(me, random1)
print("MYPLAYER: {}, RANDOM: {}\n".format(me.score, random1.score))

# CopyKitten vs. Random
copyk = CopyKitten()
random1 = Random()

print("COPYKITTEN vs RANDOM")
for _ in range(20):
  play_game(copyk, random1)
print("COPYKITTEN: {}, RANDOM: {}\n".format(copyk.score, random1.score))
