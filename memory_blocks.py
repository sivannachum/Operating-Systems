# -*- coding: utf-8 -*-
"""Lab 7: memory-blocks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ilUx4WUNq1rxeVQkNF6U0-qe8FnZAIwn
"""

from typing import List, Tuple, Set, Dict

class Block(object):
  """This represents a linear slice of memory.

  |....|xxxxx|....|
       ^ start()
             ^ end()
       ~~~~~~~ length()  
  """
  def __init__(self, start: int, length: int, name="Unnamed", used=False):
    self._start = start
    assert(length > 0)
    self._length = length
    self.name = name
    self.used = used
  def start(self) -> int:
    return self._start
  def end(self) -> int:
    return self._length + self._start
  def length(self) -> int:
    return self._length
  def begin_end(self) -> Tuple[int,int]:
    return (self.start(), self.end())
  def __eq__(self, other):
    return self.start() == other.start() and self.end() == other.end() and self.name == other.name and self.used == other.used
  def __hash__(self):
    return hash(self.name) ^ hash(self.start()) ^ hash(self.end())
  def __str__(self):
    return 'Block {}@{} len={}'.format(self.name, self.start(), self.length())
  def __repr__(self):
    return 'Block(start={}, length={}, name={})'.format(self._start, self._length, repr(self.name))

blocks = [ Block(0,1000,"Mem") ]

# Use a certain amount of memory, and split a block if it has more space than the amount needed.
def maybe_split_block(blocks: List[Block], block: Block, amount: int, name: str) -> Block:
  assert(block.length() >= amount)
  assert(not block.used)
  if block.length() == amount:
    block.name = name
    block.used = True
  else: # block is bigger than amount
    blocks.remove(block) # get rid of the existing object representing this block
    # and split it into two:

    # First new block - the one to be used
    start: int = block.start()
    length: int = amount
    used = Block(start, length, name)
    used.used = True

    # Second new block - the leftover unused space
    start = start + amount
    length = block.end() - start
    leftover_unused = Block(start, length, block.name)

    # Add the newly split blocks to the list
    blocks.append(used)
    blocks.append(leftover_unused)

maybe_split_block(blocks, blocks[0], 100, "A")
expected = [
            Block(0, 100, "A", used=True),
            Block(100, 900, "Mem", used=False)
]
assert(blocks == expected)
maybe_split_block(blocks, blocks[1], 400, "B")
expected = [
            Block(0, 100, "A", used=True),
            Block(100, 400, "B", used=True),
            Block(500, 500, "Mem", used=False)
]
assert(blocks == expected)
maybe_split_block(blocks, blocks[2], 500, "C")
expected = [
            Block(0, 100, "A", used=True),
            Block(100, 400, "B", used=True),
            Block(500, 500, "C", used=True)
]
assert(blocks == expected)

# Compact any consecutive free blocks in memory.
def compact_any_free_blocks(blocks: List[Block]) -> List[Block]:
  # First sort by block start position:
  blocks = sorted(blocks, key=lambda b: b.start())
  # Combine any adjacent blocks that are "unused"!
  # Initialize the new list of blocks to return
  new_blocks: List[Block] = []
  i = 0
  j = 0
  length = len(blocks)
  while (i < length):
    # Look at the current block
    block1 = blocks[i]
    # If it is used or the last block, just add it to the list
    if (block1.used or i == length - 1):
      new_blocks.append(block1)
      i = i+1
    # Otherwise, see if any other following blocks are unused
    else:
      j = i+1
      start: int = block1.start()
      end: int = block1.end()
      name: str = block1.name
      while (j < length):
        block2 = blocks[j]
        # If the block is used, we have found all the following unused blocks
        if (block2.used):
          break
        # Adjust the end and name for the new block formed by merging the consecutive free blocks
        else:
          end = block2.end()
          name = name + block2.name
          j = j+1    
      # Create the new merged block from the consecutive unused space
      new_block = Block(start, end-start, name)
      # Add the new block to the list
      new_blocks.append(new_block)
      i = j
  return new_blocks

ex1 = [
       Block(0,   100, "A", used=True),
       Block(100,  50, "B", used=False),
       Block(150,  50, "C", used=False),
       Block(200, 200, "D", used=False),
       Block(400,  50, "E", used=True),
       Block(450,  50, "F", used=False)
]
actual = compact_any_free_blocks(ex1)
ex1_after_compact = [
       Block(0,   100, "A", used=True),
       Block(100, 300, "BCD", used=False), # Three blocks here converted to 1.
       Block(400,  50, "E", used=True),
       Block(450,  50, "F", used=False)            
]
assert(actual == ex1_after_compact)


ex2 = [
       Block(0,   100, "A", used=True),
       Block(100,  50, "B", used=False),
       Block(150,  50, "C", used=False),
       Block(200, 200, "D", used=True),
       Block(400,  50, "E", used=True),
       Block(450,  50, "F", used=False)
]
actual = compact_any_free_blocks(ex2)
ex2_after_compact = [
       Block(0,   100, "A", used=True),
       Block(100, 100, "BC", used=False), # Two blocks here converted to 1.
       Block(200, 200, "D", used=True),
       Block(400,  50, "E", used=True),
       Block(450,  50, "F", used=False)            
]
assert(actual == ex2_after_compact)

# Questions (can be answered quickly here in comments).
## Which field on Block is the pointer address in C? start(), end(), or length()?
# Start is the pointer address in C.

## Why is ex2 easier than ex1?
# ex2 is easier than ex1 because there are only two consecutive blocks to merge rather than three.
# One can look for pairs of free blocks rather than a long chain of free blocks.
