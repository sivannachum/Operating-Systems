# -*- coding: utf-8 -*-
"""Lab 3: MLFQ / Lottery Scheduler

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ap5le1igqHPxbdhsgZccrtJ_kllv4rbj
"""

from typing import Optional, List, Set, Dict
import random

class Job(object):
  """
  This class represents the state of a simulated job: 
  its name, how long it needs to run for, when it started, etc.
  """
  def __init__(self, 
               name: str, 
               arrival_time: float, 
               duration: float, 
               tickets: Optional[float] = None,
               start_time: Optional[float] = None, 
               run_time: Optional[float]=None,
               end_time: Optional[float]=None):
    self.name = name
    self.arrival_time = arrival_time
    self.duration = duration
    self.tickets = tickets
    self.start_time = start_time
    self.run_time = run_time
    self.end_time = end_time
    self.last_run_time = 0

  def started(self) -> bool:
    """
    Has this job started yet?
    """
    return self.start_time is not None

  def finished(self) -> bool:
    """
    Has this job finished?
    """
    return self.end_time is not None
  
  def has_arrived(self, now: float) -> bool:
    """
    Given time=now, has this job "arrived" yet?
    """
    return self.arrival_time <= now

  def run(self, now: float, steps: float = 1):
    """
    Run this job for a little bit.

    Parameters
      now: what time is it now? If we're starting a job we need to save the time.
      steps: how long to run it for, e.g., 1 step, the job's duration, etc.
    """
    if self.finished():
      # crash if already finished.
      raise ValueError("Don't run a job that's finished!")

    # start the job if not started!
    if not self.started():
      self.start_time = now
      self.run_time = 0
    # Move it forward by steps amount of work.
    self.run_time += steps
    # Record last runtime as now + steps so no issue if now is 0
    self.last_run_time = now + steps
    # If that makes it done, deal with that:
    if self.run_time >= self.duration:
      # We might have gone over the needed amount of time.
      extra_time = self.run_time - self.duration
      used_time = steps - extra_time
      # record end time
      self.end_time = now + used_time

# Evaluation
# Response time, turnaround time, and fairness

def response_time(job: Job) -> float:
  return job.start_time-job.arrival_time

def turnaround_time(job: Job) -> float:
  return job.end_time-job.arrival_time

# This method gets an idea of the average fairness, though not the exact average
# Goal is to have fairness equal 1
def fairness(jobs: List[Job]) -> float:
  jobs.sort(key=lambda j:j.end_time)
  sum: int = 0
  # Compare each job to its neighbor
  n: int = len(jobs)-1
  for i in range(n):
    sum += jobs[i].end_time/jobs[i+1].end_time
  average: float = sum/n
  return average

# See Figure 7.1 from the reading!
# I'm fiddling with the arrival times to ensure the ordering they gave us.
ex_7_1 = [
          Job("A", 0.0, 1),
          Job("B", 0.1, 1),
          Job("C", 0.2, 1)
]

# A FIFO scheduler:
def fifo_scheduler(jobs: List[Job]):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobs that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # select the job that arrived first (of those alive)
    # ... break ties using names
    next_job = min(alive, key=lambda j: (j.arrival_time, j.name))

    # run it until finished
    time_step = next_job.duration
    next_job.run(time, time_step)

    print(time, next_job.name)

    # update our simulation time
    time += time_step

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# What gets printed is more-or-less the graph shown in Figure 7.1!
print("FIFO Scheduler")
fifo_scheduler(ex_7_1)

# FIFO does almost equally poorly for response time and turnaround time
print("A response time:", response_time(ex_7_1[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex_7_1[0]), "expected: 1.0")
print("B response time:", response_time(ex_7_1[1]), "expected: 0.9")
print("B turnaround time:", turnaround_time(ex_7_1[1]), "expected: 1.9")
print("C response time:", response_time(ex_7_1[2]), "expected: 1.8")
print("C turnaround time:", turnaround_time(ex_7_1[2]), "expected: 2.8")
# This scheduler is not the most fair, about .6
print("Approximate Average Fairness:", fairness(ex_7_1))

# Shortest-Job-First (SJF)

## This scheduler is a variant on FIFO, which I did for you. 
## It mostly chooses jobs by a different calculus.

ex = [
          Job("A", 0, 10),
          Job("B", 1, 5),
          Job("C", 3, 1.5)
]

# A SJF scheduler:
def sjf_scheduler(jobs: List[Job]):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobs that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # select the job with the shortest duration (of those alive)
    # ... break ties using names
    next_job = min(alive, key=lambda j: (j.duration, j.name))

    # run it until finished
    time_step = next_job.duration
    next_job.run(time, time_step)

    print(time, next_job.name)

    # update our simulation time
    time += time_step

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# Run the scheduler
print("\nSJF Scheduler")
sjf_scheduler(ex)

# SJF does better than FIFO for turnaround time and response time, though it still does not do too well for either
# SJF generally does better for turnaround time than response time
print("A response time:", response_time(ex[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex[0]), "expected: 10.0")
print("B response time:", response_time(ex[1]), "expected: 10.5")
print("B turnaround time:", turnaround_time(ex[1]), "expected: 15.5")
print("C response time:", response_time(ex[2]), "expected: 7")
print("C turnaround time:", turnaround_time(ex[2]), "expected: 8.5")
# This scheduler does well for fairness on this data set, about .8
print("Approximate Average Fairness:", fairness(ex))

# This helper method determines how much time each job has remaining
def getTimeRemaining(job) -> float:
  if job.run_time is None:
    return job.duration
  else:
    return job.duration-job.run_time

# Shortest Time-to-Completion First (STCF)

## Here the challenge will be using a fixed time_step 
## rather than setting it to the duration of the job being run.
## This scheduler chooses jobs based on which of the active jobs will be the first to complete.

ex = [
          Job("A", 0, 10),
          Job("B", 1, 5),
          Job("C", 3, 1.5)
]

# A STCF scheduler:
def stcf_scheduler(jobs: List[Job], time_step: float = 1.0):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobs that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # select the job with the shortest time left to go to finish (of those alive)
    # ... ties are broken by order in the list of jobs
    next_job = min(alive, key=getTimeRemaining)

    # run for a time slice or for the amount of time remaining for the job, depending on which is less
    time_to_run = min(time_step, getTimeRemaining(next_job))
    next_job.run(time, time_to_run)
    print(time, next_job.name)

    # update our simulation time
    time += time_to_run

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# Run the scheduler
print("\nSTCF Scheduler")
stcf_scheduler(ex)

# STCF does amazing for response time and not as well for turnaround time in this example
# STCF generally has better turnaround time than FIFO and SJF
print("A response time:", response_time(ex[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex[0]), "expected: 16.5")
print("B response time:", response_time(ex[1]), "expected: 0")
print("B turnaround time:", turnaround_time(ex[1]), "expected: 6.5")
print("C response time:", response_time(ex[2]), "expected: 0")
print("C turnaround time:", turnaround_time(ex[2]), "expected: 1.5")
# This scheduler is not very fair, about .5
print("Approximate Average Fairness:", fairness(ex))

# Round Robin

## The challenge of simulating Round-Robin (which is fair amongst alive jobs)
## is that we must keep track of who to go to next.
## Can you do this by adding a "last_run_time" field to the Job class?
## ... and keep it updated in the "run" method?

ex = [
          Job("A", 0, 10),
          Job("B", 0, 5),
          Job("C", 3, 5)
]

# A RR scheduler:
def rr_scheduler(jobs: List[Job], time_step: float = 1.0):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobs that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # circle through the jobs, based on who has not run in the longest time
    # ... break ties using names
    next_job = min(alive, key=lambda j: (j.last_run_time, j.name))

    # run for a time slice or for the amount of time remaining for the job, depending on which is less
    time_to_run = min(time_step, getTimeRemaining(next_job))
    next_job.run(time, time_to_run)
    print(time, next_job.name)

    # update our simulation time
    time += time_to_run

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# Run the scheduler
print("\nRR Scheduler")
rr_scheduler(ex)

# Round Robin does well for response time and notably poorly for turnaround time
print("A response time:", response_time(ex[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex[0]), "expected: 20.0")
print("B response time:", response_time(ex[1]), "expected: 1.0")
print("B turnaround time:", turnaround_time(ex[1]), "expected: 14.0")
print("C response time:", response_time(ex[2]), "expected: 0")
print("C turnaround time:", turnaround_time(ex[2]), "expected: 13.0")
# This scheduler is very fair, about .8
print("Approximate Average Fairness:", fairness(ex))

ex = [
          Job("A", 0, 10, 5),
          Job("B", 1, 5, 1),
          Job("C", 0, 7, 20),
          Job("D", 2, 1, 1)
]

ex_2 = [
          Job("A", 0, 10, 20),
          Job("B", 1, 5, 10),
          Job("C", 0, 7, 20),
          Job("D", 2, 1, 10)
]

# A lottery scheduler:
def lottery_scheduler(jobs: List[Job], time_step: float = 1.0):
  # Copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    # Keep track of how many tickets are in the lottery
    sum_tickets = 0

    alive = []
    # Collect only those jobs that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)
        sum_tickets += job.tickets

    # Most efficient to sort list of jobs from those with highest number of tickets to lowest
    alive.sort(key=lambda j: (j.tickets, j.name), reverse=True)

    # Select the job to run probabalistically
    # Decide on a winner and keep a counter variable to keep track of if we've found it yet
    winner = random.uniform(0, sum_tickets)
    counter: int = 0
    
    for job in alive:
      counter += job.tickets
      if (counter >= winner):
        # Run this job and break
        # Run for a time slice or for the amount of time remaining for the job, depending on which is less
        time_to_run = min(time_step, getTimeRemaining(job))
        job.run(time, time_to_run)
        print(time, job.name)
        # Update our simulation time
        time += time_to_run
        # Delete the job if it finished!
        if job.finished():
          not_finished.remove(job)
        break

# Run the scheduler
print("\nLottery Scheduler")
lottery_scheduler(ex)

# Cannot have expected response or turnaround time since lottery scheduler uses random
# The lottery scheduler does well in response time for jobs that have a lot of tickets, such as C
# but it generally does less well in response time for jobs with less tickets, such as B and D
# The same is true of the lottery scheduler regarding turnaround time
print("A response time:", response_time(ex[0]))
print("A turnaround time:", turnaround_time(ex[0]))
print("B response time:", response_time(ex[1]))
print("B turnaround time:", turnaround_time(ex[1]))
print("C response time:", response_time(ex[2]))
print("C turnaround time:", turnaround_time(ex[2]))
print("D response time:", response_time(ex[3]))
print("D turnaround time:", turnaround_time(ex[3]))
# The lottery scheduler does alright in terms of fairness, about .6-.8, depending on the run
print("Approximate Average Fairness:", fairness(ex), "\n")
# Fairness tends to stay in the range .6-.8 on data sets, though for ex_2 I did get a fairness rating of .93 for one run
lottery_scheduler(ex_2)
print("Approximate Average Fairness:", fairness(ex_2))