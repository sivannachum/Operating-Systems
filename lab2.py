# -*- coding: utf-8 -*-
"""Lab 2: schedulers

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qJb_C8b_Ax3MLuYBwH-XxneJvmF3H4j8
"""

from typing import Optional, List, Set, Dict

class Job(object):
  """
  This class represents the state of a simulated job: 
  its name, how long it needs to run for, when it started, etc.
  """
  def __init__(self, 
               name: str, 
               arrival_time: float, 
               duration: float, 
               start_time: Optional[float] = None, 
               run_time: Optional[float]=None,
               end_time: Optional[float]=None):
    self.name = name
    self.arrival_time = arrival_time
    self.duration = duration
    self.start_time = start_time
    self.run_time = run_time
    self.end_time = end_time
    self.last_run_time = 0

  def started(self) -> bool:
    """
    Has this job started yet?
    """
    return self.start_time is not None

  def finished(self) -> bool:
    """
    Has this job finished?
    """
    return self.end_time is not None
  
  def has_arrived(self, now: float) -> bool:
    """
    Given time=now, has this job "arrived" yet?
    """
    return self.arrival_time <= now

  def run(self, now: float, steps: float = 1):
    """
    Run this job for a little bit.

    Parameters
      now: what time is it now? If we're starting a job we need to save the time.
      steps: how long to run it for, e.g., 1 step, the job's duration, etc.
    """
    if self.finished():
      # crash if already finished.
      raise ValueError("Don't run a job that's finished!")

    # start the job if not started!
    if not self.started():
      self.start_time = now
      self.run_time = 0
    # Move it forward by steps amount of work.
    self.run_time += steps
    # Record last runtime as now + steps so no issue if now is 0
    self.last_run_time = now + steps
    # If that makes it done, deal with that:
    if self.run_time >= self.duration:
      # We might have gone over the needed amount of time.
      extra_time = self.run_time - self.duration
      used_time = steps - extra_time
      # record end time
      self.end_time = now + used_time

# Evaluation

## The book introduces *response time* and *turnaround time*.
## Can you code them up?

def response_time(job: Job) -> float:
  return job.start_time-job.arrival_time

def turnaround_time(job: Job) -> float:
  return job.end_time-job.arrival_time

# See Figure 7.1 from the reading!
# I'm fiddling with the arrival times to ensure the ordering they gave us.
ex_7_1 = [
          Job("A", 0.0, 1),
          Job("B", 0.1, 1),
          Job("C", 0.2, 1)
]

# A FIFO scheduler:
def fifo_scheduler(jobs: List[Job]):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobst that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # select the job that arrived first (of those alive)
    # ... break ties using names
    next_job = min(alive, key=lambda j: (j.arrival_time, j.name))

    # run it until finished
    time_step = next_job.duration
    next_job.run(time, time_step)

    print(time, next_job.name)

    # update our simulation time
    time += time_step

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# What gets printed is more-or-less the graph shown in Figure 7.1!
print("FIFO Scheduler")
fifo_scheduler(ex_7_1)

print("A response time:", response_time(ex_7_1[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex_7_1[0]), "expected: 1.0")
print("B response time:", response_time(ex_7_1[1]), "expected: 0.9")
print("B turnaround time:", turnaround_time(ex_7_1[1]), "expected: 1.9")
print("C response time:", response_time(ex_7_1[2]), "expected: 1.8")
print("C turnaround time:", turnaround_time(ex_7_1[2]), "expected: 2.8")

# Shortest-Job-First (SJF)

## This scheduler is a variant on FIFO, which I did for you. 
## It mostly chooses jobs by a different calculus.

ex = [
          Job("A", 0, 10),
          Job("B", 1, 5),
          Job("C", 3, 1.5)
]

# A SJF scheduler:
def sjf_scheduler(jobs: List[Job]):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobs that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # select the job with the shortest duration (of those alive)
    # ... break ties using names
    next_job = min(alive, key=lambda j: (j.duration, j.name))

    # run it until finished
    time_step = next_job.duration
    next_job.run(time, time_step)

    print(time, next_job.name)

    # update our simulation time
    time += time_step

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# Run the scheduler
print("\nSJF Scheduler")
sjf_scheduler(ex)
print("A response time:", response_time(ex[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex[0]), "expected: 10.0")
print("B response time:", response_time(ex[1]), "expected: 10.5")
print("B turnaround time:", turnaround_time(ex[1]), "expected: 15.5")
print("C response time:", response_time(ex[2]), "expected: 7")
print("C turnaround time:", turnaround_time(ex[2]), "expected: 8.5")

# This helper method determines how much time each job has remaining
def getTimeRemaining(job) -> float:
  if job.run_time is None:
    return job.duration
  else:
    return job.duration-job.run_time

# Shortest Time-to-Completion First (STCF)

## Here the challenge will be using a fixed time_step 
## rather than setting it to the duration of the job being run.
## This scheduler chooses jobs based on which of the active jobs will be the first to complete.

ex = [
          Job("A", 0, 10),
          Job("B", 1, 5),
          Job("C", 3, 1.5)
]

# A STCF scheduler:
def stcf_scheduler(jobs: List[Job], time_step: float = 1.0):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobs that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # select the job with the shortest time left to go to finish (of those alive)
    # ... ties are broken by order in the list of jobs
    next_job = min(alive, key=getTimeRemaining)

    # run for a time slice or for the amount of time remaining for the job, depending on which is less
    time_to_run = min(time_step, getTimeRemaining(next_job))
    next_job.run(time, time_to_run)
    print(time, next_job.name)

    # update our simulation time
    time += time_to_run

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# Run the scheduler
print("\nSTCF Scheduler")
stcf_scheduler(ex)
print("A response time:", response_time(ex[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex[0]), "expected: 16.5")
print("B response time:", response_time(ex[1]), "expected: 0")
print("B turnaround time:", turnaround_time(ex[1]), "expected: 6.5")
print("C response time:", response_time(ex[2]), "expected: 0")
print("C turnaround time:", turnaround_time(ex[2]), "expected: 1.5")

# Round Robin

## The challenge of simulating Round-Robin (which is fair amongst alive jobs)
## is that we must keep track of who to go to next.
## Can you do this by adding a "last_run_time" field to the Job class?
## ... and keep it updated in the "run" method?

ex = [
          Job("A", 0, 10),
          Job("B", 0, 5),
          Job("C", 3, 5)
]

# A RR scheduler:
def rr_scheduler(jobs: List[Job], time_step: float = 1.0):
  # copy the list of jobs!
  not_finished = jobs[:]
  time = 0
  while len(not_finished) > 0:
    alive = []
    # Collect only those jobst that are alive:
    for job in not_finished:
      if job.has_arrived(time):
        alive.append(job)

    # circle through the jobs, based on who has not run in the longest time
    # ... break ties using names
    next_job = min(alive, key=lambda j: (j.last_run_time, j.name))

    # run for a time slice or for the amount of time remaining for the job, depending on which is less
    time_to_run = min(time_step, getTimeRemaining(next_job))
    next_job.run(time, time_to_run)
    print(time, next_job.name)

    # update our simulation time
    time += time_to_run

    # delete job if it finished!
    if next_job.finished():
      not_finished.remove(next_job)

# Run the scheduler
print("\nRR Scheduler")
rr_scheduler(ex)
print("A response time:", response_time(ex[0]), "expected: 0")
print("A turnaround time:", turnaround_time(ex[0]), "expected: 20.0")
print("B response time:", response_time(ex[1]), "expected: 1.0")
print("B turnaround time:", turnaround_time(ex[1]), "expected: 14.0")
print("C response time:", response_time(ex[2]), "expected: 0")
print("C turnaround time:", turnaround_time(ex[2]), "expected: 13.0")